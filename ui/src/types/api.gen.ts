/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/admin/rbac/reload": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reload RBAC (Admin)
     * @description Force reload of RBAC policies (requires admin privileges)
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: string;
            };
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
        /** @description Forbidden */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/admin/system/info": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * System Info
     * @description Check system information (requires admin privileges)
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/admin/users": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List users (Admin)
     * @description Get list of users in the system (requires admin privileges)
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description User list with admin info */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
        /** @description Forbidden */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/introspect": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Introspect (legacy combined)
     * @deprecated
     * @description Deprecated: prefer /api/v1/introspect/user or /api/v1/introspect/server
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Combined user+server info */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: unknown;
            };
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/introspect/server": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Server introspection
     * @description Get server and cluster information
     */
    get: {
      parameters: {
        query?: {
          /** @description Whether to discover namespaces (0 or 1) */
          discover?: string;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ServerIntrospectionResponse"];
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
        /** @description Forbidden */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/introspect/user": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * User introspection
     * @description Get user-specific permissions and capabilities
     */
    get: {
      parameters: {
        query?: {
          /** @description Comma-separated list of namespaces to check */
          namespaces?: string;
          /** @description Comma-separated list of actions to check */
          actions?: string;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.UserIntrospectionResponse"];
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/me": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get current user
     * @description Get information about the current authenticated user
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.UserInfo"];
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/server/sessions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List sessions
     * @description Get a list of codespace sessions, optionally across all namespaces
     */
    get: operations["listSessions"];
    put?: never;
    /**
     * Create session
     * @description Create a new codespace session
     */
    post: operations["createSession"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/server/sessions/{namespace}/{name}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get session
     * @description Get details of a specific session
     */
    get: operations["getSession"];
    /**
     * Update session
     * @description Update a session (full replacement)
     */
    put: operations["updateSession"];
    post?: never;
    /**
     * Delete session
     * @description Delete a codespace session
     */
    delete: operations["deleteSession"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/server/sessions/{namespace}/{name}/scale": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Scale session
     * @description Scale the number of replicas for a session
     */
    post: operations["scaleSession"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/stream/sessions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream sessions
     * @description Stream real-time session updates via Server-Sent Events
     */
    get: {
      parameters: {
        query?: {
          /** @description Target namespace */
          namespace?: string;
          /** @description Stream sessions from all namespaces */
          all?: boolean;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description SSE stream */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "text/event-stream": string;
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "text/event-stream": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
        /** @description Forbidden */
        403: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "text/event-stream": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/v1/user/permissions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * User permissions
     * @description Get detailed user permissions
     */
    get: {
      parameters: {
        query?: {
          /** @description Comma-separated list of namespaces */
          namespaces?: string;
          /** @description Comma-separated list of actions */
          actions?: string;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.UserPermissions"];
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/auth/features": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get authentication features
     * @description Get available authentication methods and endpoints
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.AuthFeatures"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/auth/local/login": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Local login
     * @description Authenticate using username and password
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description Login credentials */
      requestBody: {
        content: {
          "application/json": components["schemas"]["cmd_server.LocalLoginRequest"];
        };
      };
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.LoginResponse"];
          };
        };
        /** @description Unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["cmd_server.ErrorResponse"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/auth/logout": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Logout
     * @description Clears session cookie. If SSO configured, redirects to the provider’s end-session endpoint.
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description OK */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              [key: string]: string;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/auth/sso/callback": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * OIDC callback
     * @description Handles provider callback, mints session cookie, then redirects.
     */
    get: {
      parameters: {
        query: {
          /** @description OIDC state */
          state: string;
          /** @description Authorization code */
          code: string;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Redirect */
        302: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "*/*": string;
          };
        };
        /** @description unauthorized */
        401: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "*/*": string;
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/auth/sso/login": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * OIDC start
     * @description Redirect to OIDC provider with PKCE/state. Optional `next` query to return to path.
     */
    get: {
      parameters: {
        query?: {
          /** @description Relative path to return to after login */
          next?: string;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Redirect */
        302: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "*/*": string;
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/healthz": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Health check
     * @description Check if the service is healthy
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description ok */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "text/plain": string;
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/readyz": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Readiness check
     * @description Check if the service is ready to accept traffic
     */
    get: {
      parameters: {
        query?: {
          /** @description Namespace to test connectivity */
          namespace?: string;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description ready */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "text/plain": string;
          };
        };
        /** @description not ready */
        503: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "text/plain": string;
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Available authentication features and endpoints */
    "cmd_server.AuthFeatures": {
      /** @example false */
      localLoginEnabled?: boolean;
      /** @example /auth/local/login */
      localLoginPath?: string;
      /** @example true */
      ssoEnabled?: boolean;
      /** @example /auth/sso/login */
      ssoLoginPath?: string;
    };
    "cmd_server.CasbinPermissions": {
      namespaces?: components["schemas"]["cmd_server.NamespacePermissions"];
    };
    "cmd_server.ClusterInfo": {
      casbin?: components["schemas"]["cmd_server.CasbinPermissions"];
      serverServiceAccount?: components["schemas"]["cmd_server.ServiceAccountInfo"];
    };
    "cmd_server.DomainPermissions": {
      session?: {
        [key: string]: boolean;
      };
    };
    "cmd_server.ErrorResponse": {
      /** @example Invalid request */
      error?: string;
    };
    /** @description Local login credentials */
    "cmd_server.LocalLoginRequest": {
      /** @example secretpassword */
      password: string;
      /** @example alice */
      username: string;
    };
    /** @description Successful authentication response */
    "cmd_server.LoginResponse": {
      /** @example [
       *       "editor",
       *       "viewer"
       *     ] */
      roles?: string[];
      token?: string;
      /** @example alice */
      user?: string;
    };
    "cmd_server.NamespaceInfo": {
      /** @description Namespaces user can access */
      userAllowed?: string[];
      /** @description Namespaces user can create sessions in */
      userCreatable?: string[];
      /** @description Namespaces user can delete sessions from */
      userDeletable?: string[];
    };
    "cmd_server.NamespacePermissions": {
      list?: boolean;
      watch?: boolean;
    };
    "cmd_server.PermissionCheck": {
      action?: string;
      allowed?: boolean;
      namespace?: string;
      resource?: string;
    };
    "cmd_server.ServerIntrospectionResponse": {
      capabilities?: components["schemas"]["cmd_server.SystemCapabilities"];
      cluster?: components["schemas"]["cmd_server.ClusterInfo"];
      namespaces?: components["schemas"]["cmd_server.ServerNamespaceInfo"];
      version?: components["schemas"]["cmd_server.ServerVersionInfo"];
    };
    "cmd_server.ServerNamespaceInfo": {
      /** @description All namespaces (if discoverable) */
      all?: string[];
      /** @description Namespaces containing sessions */
      withSessions?: string[];
    };
    "cmd_server.ServerVersionInfo": {
      buildDate?: string;
      gitCommit?: string;
      version?: string;
    };
    "cmd_server.ServiceAccountInfo": {
      namespaces?: components["schemas"]["cmd_server.NamespacePermissions"];
      session?: {
        [key: string]: boolean;
      };
    };
    /** @description Request body for creating a new codespace session */
    "cmd_server.SessionCreateRequest": {
      auth?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.AuthSpec"];
      home?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.PVCSpec"];
      /** @example my-session */
      name: string;
      /** @example default */
      namespace?: string;
      networking?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.NetSpec"];
      profile: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.ProfileSpec"];
      /** @example 1 */
      replicas?: number;
      scratch?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.PVCSpec"];
    };
    /** @description Response containing list of sessions with metadata */
    "cmd_server.SessionListResponse": {
      filtered?: boolean;
      items?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.Session"][];
      /** @example [
       *       "default",
       *       "kube-system"
       *     ] */
      namespaces?: string[];
      /** @example 5 */
      total?: number;
    };
    /** @description Request body for scaling a session */
    "cmd_server.SessionScaleRequest": {
      /** @example 2 */
      replicas?: number;
    };
    "cmd_server.SystemCapabilities": {
      /** @description Whether system supports multiple tenants */
      multiTenant?: boolean;
    };
    "cmd_server.UserCapabilities": {
      /** @description Whether user has admin privileges */
      adminAccess?: boolean;
      /** @description Whether user has any cluster-level access */
      clusterScope?: boolean;
      /** @description Effective namespace scope for user */
      namespaceScope?: string[];
    };
    /** @description Current authenticated user information */
    "cmd_server.UserInfo": {
      /** @example alice@company.com */
      email?: string;
      /** @example 1641081600 */
      exp?: number;
      /** @example 1640995200 */
      iat?: number;
      /** @example [
       *       "inherited-role"
       *     ] */
      implicitRoles?: string[];
      /** @example oidc */
      provider?: string;
      /** @example [
       *       "editor",
       *       "viewer"
       *     ] */
      roles?: string[];
      /** @example alice@company.com */
      subject?: string;
      /** @example alice */
      username?: string;
    };
    "cmd_server.UserIntrospectionResponse": {
      capabilities?: components["schemas"]["cmd_server.UserCapabilities"];
      domains?: {
        [key: string]: components["schemas"]["cmd_server.DomainPermissions"];
      };
      namespaces?: components["schemas"]["cmd_server.NamespaceInfo"];
      user?: components["schemas"]["cmd_server.UserInfo"];
    };
    "cmd_server.UserPermissions": {
      /** @description namespace -> allowed actions */
      namespaces?: {
        [key: string]: string[];
      };
      permissions?: components["schemas"]["cmd_server.PermissionCheck"][];
      roles?: string[];
      subject?: string;
    };
    "github_com_codespace-operator_codespace-operator_api_v1.AuthSpec": {
      /** @description +kubebuilder:validation:Enum=oauth2proxy;none
       *     +kubebuilder:default=none */
      mode?: string;
      oidc?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.OIDCRef"];
    };
    "github_com_codespace-operator_codespace-operator_api_v1.NetSpec": {
      annotations?: {
        [key: string]: string;
      };
      host?: string;
      tlsSecretName?: string;
    };
    "github_com_codespace-operator_codespace-operator_api_v1.OIDCRef": {
      clientIDSecret?: string;
      clientSecretRef?: string;
      /** @description +kubebuilder:validation:Pattern=`^https?://` */
      issuerURL?: string;
    };
    "github_com_codespace-operator_codespace-operator_api_v1.PVCSpec": {
      /** @description +kubebuilder:validation:MinLength=1 */
      mountPath?: string;
      /** @description +kubebuilder:validation:Pattern=`^\d+(Gi|Mi)$` */
      size?: string;
      storageClassName?: string;
    };
    "github_com_codespace-operator_codespace-operator_api_v1.ProfileSpec": {
      cmd?: string[];
      /** @description +kubebuilder:validation:Enum=jupyterlab;vscode;rstudio;custom */
      ide?: string;
      /** @description +kubebuilder:validation:MinLength=1 */
      image?: string;
    };
    "github_com_codespace-operator_codespace-operator_api_v1.Session": {
      /** @description APIVersion defines the versioned schema of this representation of an object.
       *     Servers should convert recognized schemas to the latest internal value, and
       *     may reject unrecognized values.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
       *     +optional */
      apiVersion?: string;
      /** @description Kind is a string value representing the REST resource this object represents.
       *     Servers may infer this from the endpoint the client submits requests to.
       *     Cannot be updated.
       *     In CamelCase.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
       *     +optional */
      kind?: string;
      metadata?: components["schemas"]["v1.ObjectMeta"];
      spec?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.SessionSpec"];
      status?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.SessionStatus"];
    };
    "github_com_codespace-operator_codespace-operator_api_v1.SessionSpec": {
      auth?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.AuthSpec"];
      home?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.PVCSpec"];
      networking?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.NetSpec"];
      profile?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.ProfileSpec"];
      replicas?: number;
      scratch?: components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.PVCSpec"];
    };
    "github_com_codespace-operator_codespace-operator_api_v1.SessionStatus": {
      /** @description Pending | Ready | Error */
      phase?: string;
      reason?: string;
      url?: string;
    };
    "v1.FieldsV1": Record<string, never>;
    "v1.ManagedFieldsEntry": {
      /** @description APIVersion defines the version of this resource that this field set
       *     applies to. The format is "group/version" just like the top-level
       *     APIVersion field. It is necessary to track the version of a field
       *     set because it cannot be automatically converted. */
      apiVersion?: string;
      /** @description FieldsType is the discriminator for the different fields format and version.
       *     There is currently only one possible value: "FieldsV1" */
      fieldsType?: string;
      /** @description FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
       *     +optional */
      fieldsV1?: components["schemas"]["v1.FieldsV1"];
      /** @description Manager is an identifier of the workflow managing these fields. */
      manager?: string;
      /** @description Operation is the type of operation which lead to this ManagedFieldsEntry being created.
       *     The only valid values for this field are 'Apply' and 'Update'. */
      operation?: components["schemas"]["v1.ManagedFieldsOperationType"];
      /** @description Subresource is the name of the subresource used to update that object, or
       *     empty string if the object was updated through the main resource. The
       *     value of this field is used to distinguish between managers, even if they
       *     share the same name. For example, a status update will be distinct from a
       *     regular update using the same manager name.
       *     Note that the APIVersion field is not related to the Subresource field and
       *     it always corresponds to the version of the main resource. */
      subresource?: string;
      /** @description Time is the timestamp of when the ManagedFields entry was added. The
       *     timestamp will also be updated if a field is added, the manager
       *     changes any of the owned fields value or removes a field. The
       *     timestamp does not update when a field is removed from the entry
       *     because another manager took it over.
       *     +optional */
      time?: string;
    };
    /** @enum {string} */
    "v1.ManagedFieldsOperationType": "Apply" | "Update";
    "v1.ObjectMeta": {
      /** @description Annotations is an unstructured key value map stored with a resource that may be
       *     set by external tools to store and retrieve arbitrary metadata. They are not
       *     queryable and should be preserved when modifying objects.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
       *     +optional */
      annotations?: {
        [key: string]: string;
      };
      /** @description CreationTimestamp is a timestamp representing the server time when this object was
       *     created. It is not guaranteed to be set in happens-before order across separate operations.
       *     Clients may not set this value. It is represented in RFC3339 form and is in UTC.
       *
       *     Populated by the system.
       *     Read-only.
       *     Null for lists.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       *     +optional */
      creationTimestamp?: string;
      /** @description Number of seconds allowed for this object to gracefully terminate before
       *     it will be removed from the system. Only set when deletionTimestamp is also set.
       *     May only be shortened.
       *     Read-only.
       *     +optional */
      deletionGracePeriodSeconds?: number;
      /** @description DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
       *     field is set by the server when a graceful deletion is requested by the user, and is not
       *     directly settable by a client. The resource is expected to be deleted (no longer visible
       *     from resource lists, and not reachable by name) after the time in this field, once the
       *     finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
       *     Once the deletionTimestamp is set, this value may not be unset or be set further into the
       *     future, although it may be shortened or the resource may be deleted prior to this time.
       *     For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
       *     by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
       *     the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
       *     remove the pod from the API. In the presence of network partitions, this object may still
       *     exist after this timestamp, until an administrator or automated process can determine the
       *     resource is fully terminated.
       *     If not set, graceful deletion of the object has not been requested.
       *
       *     Populated by the system when a graceful deletion is requested.
       *     Read-only.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
       *     +optional */
      deletionTimestamp?: string;
      /** @description Must be empty before the object is deleted from the registry. Each entry
       *     is an identifier for the responsible component that will remove the entry
       *     from the list. If the deletionTimestamp of the object is non-nil, entries
       *     in this list can only be removed.
       *     Finalizers may be processed and removed in any order.  Order is NOT enforced
       *     because it introduces significant risk of stuck finalizers.
       *     finalizers is a shared field, any actor with permission can reorder it.
       *     If the finalizer list is processed in order, then this can lead to a situation
       *     in which the component responsible for the first finalizer in the list is
       *     waiting for a signal (field value, external system, or other) produced by a
       *     component responsible for a finalizer later in the list, resulting in a deadlock.
       *     Without enforced ordering finalizers are free to order amongst themselves and
       *     are not vulnerable to ordering changes in the list.
       *     +optional
       *     +patchStrategy=merge
       *     +listType=set */
      finalizers?: string[];
      /** @description GenerateName is an optional prefix, used by the server, to generate a unique
       *     name ONLY IF the Name field has not been provided.
       *     If this field is used, the name returned to the client will be different
       *     than the name passed. This value will also be combined with a unique suffix.
       *     The provided value has the same validation rules as the Name field,
       *     and may be truncated by the length of the suffix required to make the value
       *     unique on the server.
       *
       *     If this field is specified and the generated name exists, the server will return a 409.
       *
       *     Applied only if Name is not specified.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
       *     +optional */
      generateName?: string;
      /** @description A sequence number representing a specific generation of the desired state.
       *     Populated by the system. Read-only.
       *     +optional */
      generation?: number;
      /** @description Map of string keys and values that can be used to organize and categorize
       *     (scope and select) objects. May match selectors of replication controllers
       *     and services.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
       *     +optional */
      labels?: {
        [key: string]: string;
      };
      /** @description ManagedFields maps workflow-id and version to the set of fields
       *     that are managed by that workflow. This is mostly for internal
       *     housekeeping, and users typically shouldn't need to set or
       *     understand this field. A workflow can be the user's name, a
       *     controller's name, or the name of a specific apply path like
       *     "ci-cd". The set of fields is always in the version that the
       *     workflow used when modifying the object.
       *
       *     +optional
       *     +listType=atomic */
      managedFields?: components["schemas"]["v1.ManagedFieldsEntry"][];
      /** @description Name must be unique within a namespace. Is required when creating resources, although
       *     some resources may allow a client to request the generation of an appropriate name
       *     automatically. Name is primarily intended for creation idempotence and configuration
       *     definition.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
       *     +optional */
      name?: string;
      /** @description Namespace defines the space within which each name must be unique. An empty namespace is
       *     equivalent to the "default" namespace, but "default" is the canonical representation.
       *     Not all objects are required to be scoped to a namespace - the value of this field for
       *     those objects will be empty.
       *
       *     Must be a DNS_LABEL.
       *     Cannot be updated.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
       *     +optional */
      namespace?: string;
      /** @description List of objects depended by this object. If ALL objects in the list have
       *     been deleted, this object will be garbage collected. If this object is managed by a controller,
       *     then an entry in this list will point to this controller, with the controller field set to true.
       *     There cannot be more than one managing controller.
       *     +optional
       *     +patchMergeKey=uid
       *     +patchStrategy=merge
       *     +listType=map
       *     +listMapKey=uid */
      ownerReferences?: components["schemas"]["v1.OwnerReference"][];
      /** @description An opaque value that represents the internal version of this object that can
       *     be used by clients to determine when objects have changed. May be used for optimistic
       *     concurrency, change detection, and the watch operation on a resource or set of resources.
       *     Clients must treat these values as opaque and passed unmodified back to the server.
       *     They may only be valid for a particular resource or set of resources.
       *
       *     Populated by the system.
       *     Read-only.
       *     Value must be treated as opaque by clients and .
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
       *     +optional */
      resourceVersion?: string;
      /** @description Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
       *     +optional */
      selfLink?: string;
      /** @description UID is the unique in time and space value for this object. It is typically generated by
       *     the server on successful creation of a resource and is not allowed to change on PUT
       *     operations.
       *
       *     Populated by the system.
       *     Read-only.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
       *     +optional */
      uid?: string;
    };
    "v1.OwnerReference": {
      /** @description API version of the referent. */
      apiVersion?: string;
      /** @description If true, AND if the owner has the "foregroundDeletion" finalizer, then
       *     the owner cannot be deleted from the key-value store until this
       *     reference is removed.
       *     See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
       *     for how the garbage collector interacts with this field and enforces the foreground deletion.
       *     Defaults to false.
       *     To set this field, a user needs "delete" permission of the owner,
       *     otherwise 422 (Unprocessable Entity) will be returned.
       *     +optional */
      blockOwnerDeletion?: boolean;
      /** @description If true, this reference points to the managing controller.
       *     +optional */
      controller?: boolean;
      /** @description Kind of the referent.
       *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
      kind?: string;
      /** @description Name of the referent.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names */
      name?: string;
      /** @description UID of the referent.
       *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids */
      uid?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  listSessions: {
    parameters: {
      query?: {
        /** @description Target namespace */
        namespace?: string;
        /** @description List sessions across all namespaces */
        all?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.SessionListResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
    };
  };
  createSession: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Session creation request */
    requestBody: {
      content: {
        "application/json": components["schemas"]["cmd_server.SessionCreateRequest"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.Session"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
    };
  };
  getSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace */
        namespace: string;
        /** @description Session name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.Session"];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
    };
  };
  updateSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace */
        namespace: string;
        /** @description Session name */
        name: string;
      };
      cookie?: never;
    };
    /** @description Session update request */
    requestBody: {
      content: {
        "application/json": components["schemas"]["cmd_server.SessionCreateRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.Session"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
    };
  };
  deleteSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace */
        namespace: string;
        /** @description Session name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            [key: string]: string;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
    };
  };
  scaleSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace */
        namespace: string;
        /** @description Session name */
        name: string;
      };
      cookie?: never;
    };
    /** @description Scale request */
    requestBody: {
      content: {
        "application/json": components["schemas"]["cmd_server.SessionScaleRequest"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["github_com_codespace-operator_codespace-operator_api_v1.Session"];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["cmd_server.ErrorResponse"];
        };
      };
    };
  };
}
